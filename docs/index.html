<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.4"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Embedded Artistry C Interfaces: Abstract Interfaces Written in C</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">Embedded Artistry C Interfaces
   </div>
   <div id="projectbrief">A reference collection of abstract interfaces in C.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.4 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Abstract Interfaces Written in C </div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p ><a class="anchor" id="md_README"></a> This is a collection of abstract interfaces written in C. You can view this collection in multiple ways:</p>
<ul>
<li>A ongoing study in interface design and documentation</li>
<li>A reference library of abstract interfaces we've found useful</li>
<li>A source of inspiration for creating your own interfaces</li>
<li>Examples of how the same basic interface concept can be varied to support different use cases (e.g., blocking vs non-blocking)</li>
<li>Example interfaces you can take, modify, and use on your own projects</li>
</ul>
<p >This collection is intended to serve as a reference only. The interfaces are subject to change. Do not rely on this repository remaining fixed - no guarantees are provided. If you need something, make a copy!</p>
<h1>API Documentation</h1>
<p >Generated API documentation can be found on the <a href="https://embvm.github.io/c-interfaces/">github-pages site for this repository</a>. You can <a href="https://embvm.github.io/c-interfaces/annotated.html">jump right to the list of types</a> or <a href="https://embvm.github.io/c-interfaces/files.html">the list of files</a>.</p>
<p >Note that some links in the front-page (README) will not work as they are targeted for GitHub and incompatible with Doxygen. Other links will work properly.</p>
<h1>Organization</h1>
<ul>
<li><a href="virtual_devices/">virtual_devices</a> contains abstract interfaces that can be mapped onto hardware devices.</li>
</ul>
<h1>Interface Conventions</h1>
<p >In general, our interface design adheres to the following conventions:</p>
<ul>
<li>Interface types are nouns, and the first letter of the name will be capitalized (e.g., as in German)</li>
<li>Function names are verbs that describe the action taken. This means we prefer the use of <code>getTemperature()</code> over <code>temperature()</code>.</li>
<li>We have tried to be specific: <code>temp0.getTemperature()</code> is preferred over <code>temp0.read()</code>.<ul>
<li>There are examples in this repository that provide multiple values (such as the <a href="virtual_devices/barometric_sensor.h">barometric_sensor</a>, which can produce both <em>pressure</em> and <em>altitude</em>), and as such we have opted for more specific naming across the board.</li>
<li>We think it is reasonable to use something like <code>read</code> as the method name when accessing data from sensors. For example, you might have a consistent sensor "base" interface that expects <code>read</code> to be defined for all sensor types. This is a suitable approach, and these interfaces can be easily modified to support such cases.</li>
</ul>
</li>
</ul>
<h1>Interface Scope</h1>
<p >In general, we have opted to keep the interfaces as simple as possible. You will probably see interfaces with fewer functions and parameters than you might expect. Smaller interfaces are much easier to understand, implement, and use. Our goal is also to abstract <em>only the common functionality required by general application code</em> - code that is designed to be independent of any particular hardware platform, OS, or SDK.</p>
<p >We have generally left out initialization, configuration, and special operating modes. In our view, these details are hard to generalize (since each component, library, driver, etc. has slightly different options), and general application code does not need to access this information to do its job. Some part of the system will always be responsible for instantiating the specific implementation and mapping the implementation to an abstract interface. That part of the system can use the implementation's APIs to put the component in the system's expected state during initialization. That expectation means we can leave out a number of details.</p>
<p >Because we have tried to keep the interfaces as lean as possible, we have focused on the core idea for each type of interface. These interfaces can naturally be extended in many ways. Whenever we find a reusable interface pattern, we will note it here. Do not feel constrained by our lean focus - free to compose, edit, and tune these interfaces to suit the needs of <em>your</em> system!</p>
<h1>Abstract Interface Approach</h1>
<p >The abstract interfaces we specify here are generally going to be <code>struct</code>s of function pointers.</p>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div>
<div class="line">    int32_t (*altitude)();</div>
<div class="line"> </div>
<div class="line">    void (*seaLevelPressure)(uint32_t slp);</div>
<div class="line">} BaroAltimeter;</div>
</div><!-- fragment --><p >You would need to create your own functions with the same prototypes as those described by the <code>struct</code> function pointers. Then, you declare an instance of the interface <code>struct</code> and specify your functions as the values for the member variables.</p>
<div class="fragment"><div class="line"><span class="keyword">const</span> BaroAltimeter alt0 =</div>
<div class="line">{</div>
<div class="line">    BME280_alt0_altitude,</div>
<div class="line">    BME280_alt0_seaLevelPressure,</div>
<div class="line">};</div>
</div><!-- fragment --><p >You invoke the desired function by accessing the appropriate member variable:</p>
<div class="fragment"><div class="line">int32_t current_altitude = alt0.getAltitude();</div>
</div><!-- fragment --><p >This basic approach can be extended to support inheritance and polymorphism. For more information, see <a href="https://embeddedartistry.com/fieldatlas/technique-inheritance-and-polymorphism-in-c/">"Technique: Inheritance and Polymorphism in C"</a>.</p>
<h1>Further Reading</h1>
<p >For more on interface design, abstraction, and decoupling:</p>
<ul>
<li><a href="https://embeddedartistry.com/course/designing-embedded-systems-for-change/">Designing Embedded Software for Change</a></li>
<li><a href="https://embeddedartistry.com/course/abstractions-and-interfaces/">Abstractions and Interfaces</a></li>
<li><a href="https://embeddedartistry.com/fieldmanual-terms/information-hiding/">Information Hiding</a></li>
</ul>
<p >For more on C-specific techniques:</p>
<ul>
<li><a href="https://embeddedartistry.com/fieldatlas/technique-objects-in-c/">Technique: Objects in C</a></li>
<li><a href="https://embeddedartistry.com/fieldatlas/encapsulation-and-information-hiding-in-c/">Technique: Encapsulation and Information Hiding in C</a></li>
<li><a href="https://embeddedartistry.com/fieldatlas/technique-inheritance-and-polymorphism-in-c/">Technique: Inheritance and Polymorphism in C</a> </li>
</ul>
</div></div><!-- PageDoc -->
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.4
</small></address>
</body>
</html>
